# Тестовое задание – Dashboard мониторинга ёкаев

## 1. Контекст (Легенда)

Вы разрабатываете дашборд для организации по отлову ёкаев (духов).  
Операторам необходимо в реальном времени отслеживать всплески духовной энергии в районах Токио и оперативно отправлять отряды зачистки.

Цель – проверить архитектурное мышление, работу с асинхронными данными и real-time обновлениями в рамках современного стека React / Next.js.

---

## 2. Цель задания

Разработать SPA-приложение на базе **Next.js (App Router)** для мониторинга аномалий (духов) в реальном времени.

---

## 3. Технические требования

### Стек
- **Core**
    - React 18+
    - Next.js (App Router)

- **Architecture**
    - Строгий **Feature Sliced Design (FSD)**

- **State & Async**
    - TanStack Query (React Query)

- **Styling**
    - SCSS Modules
    - ❌ Запрещено: Tailwind, Styled Components

- **Validation**
    - Zod
    - Валидация **всех входящих данных** (API, SSE)

- **DevOps**
    - Docker
    - Docker Compose
    - Проект должен запускаться одной командой:
      ```bash
      docker-compose up
      ```

---

## 4. Функциональные требования

Приложение состоит из **одной страницы**:
### 4.1 Список аномалий

- Отобразить список духов в виде карточек.
- Данные получать из мокового API, реализованного через **Next.js Route Handlers**.
- Обязательные поля:
    - **Имя** – например: `Kitsune`
    - **Уровень угрозы** – с цветовой индикацией  
      (например: Low / Medium / High / Critical)
    - **Локация** – район Токио
    - **Статус**
        - `Active` – активен
        - `Captured` – пойман

---

### 4.2 Взаимодействие – Capture

- В каждой карточке должна быть кнопка **Capture**.
- При нажатии:
    - Отправляется мутация на API.
    - Применяется **Optimistic Update** – статус меняется сразу.
    - API с вероятностью **30%** возвращает ошибку.

#### Поведение при ошибке
- Интерфейс должен:
    - Откатить состояние к предыдущему
    - Показать уведомление об ошибке (любой разумный UX-вариант)

---

### 4.3 Real-time обновления

- Реализовать:
    - **Server-Sent Events (SSE)**  
      или
    - Имитацию WebSocket

- Логика:
    - Каждые **5 секунд** случайный дух меняет уровень угрозы  
      (например: `Low → Critical`)
    - Изменения приходят с сервера
    - UI обновляется **без перезагрузки страницы**

---

## 5. Архитектурные ожидания

- Чёткое соблюдение FSD:
    - `app`
    - `pages` / `routes`
    - `entities`
    - `features`
    - `shared`
- Разделение:
    - API-слоя
    - UI
    - бизнес-логики
- Типизация данных
- Zod используется как источник истины для схем данных

---

## 6. Результат

- Ссылка на публичный **GitHub-репозиторий**
- В корне проекта должен находиться:
    - `docker-compose.yml`
- Проект запускается локально командой:
  ```bash
  docker-compose up
